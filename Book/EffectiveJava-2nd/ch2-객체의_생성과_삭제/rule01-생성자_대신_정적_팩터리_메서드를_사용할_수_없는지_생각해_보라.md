# 규칙1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는 생각해 보라
- 클래스에 public으로 선언된 정적 팩터리 메서드를 추가한다.
- 디자인 패턴에 나오는 팩터리 메서드와 다르다는 점에 유의

## 장점
1. 생성자와는 달리 정적 팩터리 메서드에는 이름이 있다.
    - 코드의 가독성이 높아진다.
    - 같은 시그니처(파라미터?)를 갖는 생성자를 여러 개 정의해야 될 경우 정적 팩터리 메서드로 바꾸고 메서드 이름으로 차이를 드러낸다.

2. 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요는 없다.
    - 변경 불가능 클래스라면 이미 만들어 둔 객체를 활용할 수 있고, 만든 객체를 캐시 해놓고 재사용할 수 있다.
    - Boolean.valueOf(Boolean) : ```경량(Flyweight) 패턴```과 유사
    - 객체의 갯수 제어 가능
        - 싱글턴 패턴 가능
        - 객체 생성이 불가능한 클래스를 만들 수 있다
        - 변경 불가능 클래스는 두 개의 같은 객체가 존재하지 못하도록 할 수 있다.
        
3. 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다.
    - public 선언되지 않은 클래스의 객체를 반환하는 API를 만들 수 있다.
    - 인터페이스 기반 프레임워크 구현에 적합
    - 인터페이스는 정적 메서드 팩터리 메서드의 반환값 자료형으로 이용된다.
    - 반환하는 클래스가 public일 필요 없다.
    - 어떤 클래스의 객체를 만들지 동적으로 결정 가능.(제네릭 사용?)
    - 서비스 제공자 프레임워크의 근간을 이룬다.
        - 서비스 인터페이스
            - JDBC의 Connection
        - 제공자 등록 API
            - JDBC의 DriverManager.registerDriver
        - 서비스 접근 API
            - JDBC의 DriverManager.getConnection
        - 서비스 제공자 인터페이스
            - 서비스 구현체의 객체 생성
            - JDBC의 Driver

4. 형인자 자료형(제네릭?) 객체를 만들 때 편하다.
    - 컴파일러가 자료형 유추를 할 수 있도록 한다.
    - <> 연산자가 생기면서 표준 컬렉션 메서드에 정적 팩터리 메서드를 추가할 필요가 없어졌다.

## 단점
1. public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다.
    - 계승(inheritance) 대신 구성(composition) 기법을 쓰도록 장려한다는 점에서 더 좋다는 사람도 있다.

2. 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다.
    - 사용법 파악이 어려움.
    - 정적 팩터리 메서드임을 알려줘야 한다.
    - naming
        - valueOf: 인자로 주어진 값과 같은 값을 갖는 객체
        - of: valueOf를 간단하게
        - getInstance: 인자에 기술된 객체를 번환하지만, 인자와 같은 값을 갖지 않을 수 있다.
        - newInstance: getInstance와 같지만 호출마다 새로운 객체 반환.
        - getType: getInstance와 같지만, 반환될 객체의 클래스와 다른 클래스에 팩터리 메서드가 있을 때 사용.

**정적 팩터리 메서드를 고려해 보지도 않고 무조건 public 생성자를 만드는 것은 삼가하자.**
            