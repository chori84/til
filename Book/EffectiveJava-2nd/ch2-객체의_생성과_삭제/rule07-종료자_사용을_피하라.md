# 규칙7 종료자 사용을 파하라
- 종료자는 예측 불가능하며, 대체로 위험하고, 일반적으로 불필요하다.
- C++의 소멸자와는 다르다.
- 즉시 실행되는 보장이 없다.
    - 참조가 사라지고 나서 종료자가 실행되기까지 긴 시간이 걸릴 수 있다.
- 긴급한 작업을 종료자 안에서 처리하면 안된다.
- 종료자 실행 시점은 JVM 마다 다르다.
- 종료자를 붙이면 객체 메모리 반환이 지연될 수도 있다.
    - 종료자 스레드 우선순위가 다른 애플리케이션 스레드 보다 낮으면.
- 중요 상태 정보는 종료자로 갱신하면 안된다.
- System.gc, System.runFinalization 같은 메서드는 종료자 실행을 보장하지 않는다.
- System.runFinalizersOnExit, Runtime.runFinalizersOnExit는 종료자 실행을 보장하지만 심각한 결함을 갖고 있어 명세에서 폐기되었다.
    - ```이런 API들은 함부로 호출하면 성능 저하에 크게 영향을 준다고 들었는데...```
- 종료자 안에서 처리 중 무점검 예외가 던저지면 종료 과정이 중단되어 객체의 상태를 망가 뜨릴 수 있다.
- 종료자를 사용하면 프로그램 성능이 심각하게 떨어진다.
- 명시적 종료 메서드를 하나 정의하여 파일이나 스레드를 반환하거나 삭제한다.
- private으로 상태 필드를 만들어 객체의 상태를 검사한다.
- 종료 메서드를 호출하지 않으면 성능이 심각하게 떨어진다.
- 명시적 종료 메서드는 try-finally 문과 함께 쓰인다.
    - 객체 종료를 보장하기 위해서.

## 종료자를 사용하기 적합한 곳
- 명시적 종료 메서드 호출을 잊을 경우에 대비하는 안정망
    - 종료자는 반환되지 않은 자원을 발견하면 반드시 경고 메시지를 로그로 남긴다.
    - 추가적인 비용을 감당하면서 구현할 만한 가치가 있는지 고려한다.
- 네이티브 피어와 연결된 객체를 다룰 때
    - 네이티브 피어가 중요한 자원을 점유하고 있지 않다면, 종료자는 그런 객체의 반환에 걸맞다.
    - 네이티브 피어가 즉시 종료되어야 하는 자원을 포함하면, 종료 메서드를 추가해야 한다.

## 주의
- 클래스가 종료자를 갖고 있고 하위 클래스가 종료자를 재정의 할 경우 하위 클래스 종료자에서 상위 클래스의 종료자를 호출해야 한다.
    - 하위 클래스 상태는 try 블록에서 종료, 상위 클래스 종료자는 finally 블록에서 호출
- 방지법 : 종료되어야 하는 모든 객체마다 여벌의 객체를 하나 더 만든다.
    - 익명 클래스 안에 종료자를 정의
    - 이 익명 클래스를 포함하는 클래스의 객체를 종료 시킴.
