# Abstract Loop & Lazy Execution

## Abstract Loop

### Complex Recursion
- 단순한 배열을 루프인 경우는 간단히 이터레이션을 작성할 수 있음.

```javascript
{
    [Symbol.iterator]() { return this; },
    data: [1,2,3,4],
    next() {
        return {
            done: this.data.length == 0,
            value: this.data.shift()
        };
    }
}
```

- 복잡한 다층형 그래프는 어떻게 이터레이션할 것인가?

```javascript
{
    [Symbol.iterator]() { return this; },
    data: [{a:[1,2,3,4], b:'-'}, [5,6,7], 8, 9],
    next() {
        let v;
        while(v = this.data.shift()) {
            switch(true) {
                case Array.isArray(v):
                    this.data.unshift(...v);
                    break;
                case v && typeof v == 'object':
                    for(var k in v) this.data.unshift(v[k]);
                    break;
                default:
                    return {value: v, done: false};
            }
        }
        return {done: true};
    }
}

const data = [
    { a: [1, 2, 3, 4], b: '-' },
    [5, 6, 7],
    8, 9
];

const next = () => {
    let v;
    while(v = data.shift()) {
        switch(true) {
            case Array.isArray(v):
                data.unshift(...v);
                break;
            case v && typeof v == 'object':
                for(var k in v) data.unshift(v[k]);
                break;
            default:
                return {value: v, done: false};
        }
    }
    return {done: true};
}

const a = {
    [Symbol.iterator]() {
        return this;
    },
    next
}

console.log([...a]);
```

```javascript
const Compx = class {
    constructor(data) { this.data = data; }
    [Symbol.iterator]() {
        const data = JSON.parse(JSON.stringify(this.data));
        return {
            next() {
                let v;
                while(v = data.shift()) {
                    if(!(v.instaceof Object)) return {value: v};
                    if(!Array.isArray(v)) v = Object.values(v);
                    data.unshift(...v);
                }
            }
            
            return {done:true};
        };
    }
};

const a = new Compx([{a:[1,2,3,4], b:'-'}, [5,6,7], 8, 9]);
console.log([...a]);
console.log([...a]);
```

- if-if 구문은 잘 못 짠 구문이다.
- if와 if가 있다는 것은 병렬적인 관계라는 것인데 첫번째 if에서 return을 할 수 있기 때문에 shield pattern으로 쓰인다.
- 실제로 이 코드가 지향하는 것은 boolean 형태. 즉, 둘 중에 하나를 반드시 거쳐가야 되는 것이다.
- Object에 소속된 얘 이거나 아니거나 상황이어야 하는데 그것을 어김.
- 만약 return을 안하고 yield를 쓰면 오류가 발생할 수 있다.

```javascript
const Compx = class {
    constructor(data) { this.data = data; }
    *gene() {
        const data = JSON.parse(JSON.stringify(this.data));
        let v;
        while(v = data.shift()) {
            if(!(v instanceof Object)) yield v;
            else {
                if(!Array.isArray(v)) v = Object.values(v);
                data.unshift(...v);
            }
        }
    }
};

const a = new Compx([{a:[1,2,3,4], b:'-'}, [5,6,7], 8, 9]);
console.log([...a.gene()]);
console.log([...a.gene()]);
```

- Object의 인스턴스 일 때도 동작하고 아닐 때도 동작한다.
- yield가 실행되도 그 밑에가 쭉 실행 됨.

### Abstract Loop
- 다양한 구조의 루프와 무관하게 해당 값이나 상황의 개입만 하고 싶은 경우
- 외부에서 루프를 돌면서 원하는 기능을 값만 넣어서 외부에서 처리함.
- for of를 보면 generator로 만든 iteration은 값만 제공하지 값을 소비하는 쪽은 for문 안에 넣던지 마음대로 할 수 있다.
- 루프를 도는 행위는 객체 쪽에서 책임지고, 바깥 쪽에 for of 같은 것은 그냥 실행기일 뿐이다. 즉, 그저 다음 값을 주는 것이다.

```javascript
// 1
(data, f) => {
    let v;
    while(v = data.shift()) {
        if(!(v instanceof Object)) f(v);
        else {
            if(!Array.isArray(v)) v = Object.values(v);
            data.unshift(...v);
        }
    }
}
// 2
(data, f) => {
    let v;
    while(v = data.shift()) {
        if(!(v instanceof Object)) {
            console.log(v);
            f(v);
        } else {
            if(!Array.isArray(v)) v = Object.values(v);
            data.unshift(...v);
        }
    }
}
```

- 1과 2는 console.log 외엔 똑같은 코드인데 1에서 2를 만들 수 없다.
- 즉, 중복을 필할 방법이 없다.
- 제어문을 재활용할 수 없으므로 중복 정의할 수 밖에 없다.

```javascript
(data, f) => {
    let v;
    while(v = data.shift()) {
        if(!(v instanceof Object)) {
            // v로 뭔가 하는 부분
        } else {
            if(!Array.isArray(v)) v = Object.values(v);
            data.unshift(...v);
        }
    }
}
```

- 결국 제어문을 직접 사용할 수 없고 구조객체를 이용해 루프실행기를 별도로 구현

```javascript
(data, f) => {
    let v;
    while(v = data.shift()) {
        if(!(v instanceof Object)) {
            f(v);
        } else {
            if(!Array.isArray(v)) v = Object.values(v);
            data.unshift(...v);
        }
    }
}
```

- 전체 데이터를 루프 도는 일반화 되어 있는 골격으로 본다.
- 제어문의 로직은 바뀔 수 없지만 제어 타이밍 마다 값(데이터)을 바꿀 수 있다.
- 데이터를 어떻게 처리할지 두가지가 있는 것이다. (Object일 때와 아닐 때) - 개별 구조 객체
- 전략이 늘어나면 코드를 변경해야 하는데 함수를 함부로 변경할 수 없다.
- 이 제어문은 정교하고 잘 작동하지만 유지보수 불가능한 함수이다.
- 골격 안에 여러가지 전략들을 교체해서 넣을 수 있다는 시각을 가져야 한다.
- 종료(terminate) 전략과 나머지 전략이 있는 것이다.
- 나머지 전략은 많이 늘어날 수 있지만 종료 전략은 하나 뿐이다.

- 팩토리 + 컴포지트

```javascript
const Operator = class {
    static factory(v) {
        if(v instanceof Object) {
            if(!Array.isArray(v)) v = Object.values(v);
            return new ArrayOp(v.map(v=>Operator.factory(v)));
        } else return new PrimeOp(v);
    }
    constructor(v) { this.v = v; }
    operation(f) { throw 'override'; }
};

const PrimeOp = class extends Operator {
    constructor(v) { super(v); }
    operation(f) { f(this.v); }
};

const ArrayOp = class extends Operator {
    constructor(v) { super(v); }
    operation(f) { for(const v of this.v) v.operation(f); }
};

Operator.factory([1,2,3,{a:4, b:5},6,7]).operation(console.log);
```

- 추상 클래스인 Operator의 메소드 두가지를 보면 생성자에서 원본 데이터 v를 잡아두고 있고, operation을 오버라이드 해야한다.
- 첫번째 자식은 종결자이자 primitive type을 처리한다.
    - 생성자는 v를 부모 생성자에 넘긴다.
    - operation은 f에게 this.v를 넘긴다.
- Array일 때 전략
    - operation이 for of로 자기의 원소를 쭉 돌면서 각각의 원소의 operation을 실행하면 할 일이 끝난다.
- 팩토리 패턴을 쓰는 큰 이유 중에 하나는 일반적으로 의존성이 있다는 것이다.
- 전부 알아야 되는 책임을 한군데에 몰아 넣는다. 
- 부모의 factory에서 어떤 값 v를 받으면 이 v가 Object인 경우와 아닌 경우가 있을 것이다.
    - 아닌 경우엔 PrimaOp를 리턴해주면 끝난다.
    - Object인 경우엔 Array가 아니라면 Object.values를 얻고, Array라면 ArrayOp를 얻을 건데, 얘의 자식들(원소)은 또 Operator 객체여야 한다.
    - 따라서 map을 통해서 원래 있던 원소를 Operator.factory에 다시 보낸다.
    - ArrayOp이 작동하는 방법이 원소의 operation을 호출하고 있다는 것은 모든 원소가 Operator의 자식 객체라고 믿고 있다는 것이기 때문에
    원소들을 Operator의 자식 객체로 만들어줘야 한다.
    - 자식의 원래 있던 원소들은 여러 타입이 있을 수 있지만 factory에게 맡기면 알아서 줄 것이기 때문에 신경 안쓴다.
    - map을 통해서 모든 원소는 싹 다 Operator가 되있는 상태의 배열을 얻을 것이다.