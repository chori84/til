# Iteration & Generator

## Interface
- 인터페이스란 사양에 맞는 값과 연결된 속성키의 셋트 - 가장 중요
- 어떤 Object라도 인터페이스의 정의를 충족시킬 수 있다.
- 하나의 Object는 여러개의 인터페이스를 충족시킬 수 있다.

### Interface Test
- test라는 키를 갖고
- 값으로 문자열인자를 1개 받아 불린결과를 반환하는 함수가 온다.

```javascript
const object = {
    test(str) {
        return true;
    }
}

const T = class {
    test(str) {
        return true;
    }
};

const test = new Test();
```

### Iterator Interface
- next라는 키를 갖고
- 값으로 인자를 받지 않고 iteratorResultObject를 반환하는 함수가 온다.
- IteratorResultObject는 value와 done이라는 키를 갖고 있다.
- 이중 done은 계속 반복할 수 있을지 없을지에 따라 불린 값을 반환한다.

```javascript
const iterator = {
    next() {
        return {
            done: true,
            value: 1
        };
    }
};

{
    data: [1,2,3,4],
    next: function() {
        return {
            done: this.data.length == 0,
            value: this.data.pop()
        };
    }
}
```

### Iterable Interface
- Symbol.iterator라는 키를 갖고
- 값으로 인자를 받지 않고 Iterator Object를 반환하는 함수가 온다.
- Symbol은 ES6 이후에 생긴 primitive type 데이터
- 모든 Symbol은 값이 유니크하다.
- Object의 key로 사용하려면 새로운 문법을 사용해야 된다.

```javascript
const Iterator = class{
    constructor() {
        this.data = [1,2,3,4];
    }
    
    next() {
        return {
            done: this.data.length === 0,
            value: this.data.pop()
        };
    }
}

const iterable = {
    // Symbol을 Object의 key로 사용하는 방법
    // === ['@@iterator']
    // === key: function() { }
    [Symbol.iterator]() {
        return iterator;
    }
}

{
    [Symbol.iterator]: function() {
        return {
            next: function() {
                return {value:1, done:false};
            }
        };
    }
}
```

## LOOP

### while문으로 살펴보는 Iterator

```javascript
let arr = [1,2,3,4];
while(arr.length > 0) {
    console.log(arr.pop());
}

while(계속 반복할지 판단) {
    반복시마다 처리할 것
}
```

- Iterator Interface

```javascript
{
    arr: [1,2,3,4],
    next() {
        return {
            done: this.arr.length == 0,         // 계속 반복할지 판단
            value: console.log(this.arr.pop())  // 반복시마다 처리할 것
        };
    }
}
```

- 문으로 하는 일은 휘발성
- 값은 통제할 수 있다.
- 더 이상 ()가 없다고 함수 호출이 아니라고 생각하면 안된다.
    - get
- lazy
    - 실행하다 런타임에 실행할지 안할지 결정이 된다.
    - 제어문(연산자)을 이용한 lazy 판단
    - 호출 지연 : 코드를 함수에 가두면 함수가 실행될 때 코드가 실행된다.
- while문은 무조건 동작하는 횟수가 정해져있는데 Iterator Interface는 호출지연이 가능하다.
- while은 엔진이 알아서 동작해주지만 Iterator Interface는 실행기를 밖에 둬야 한다. - next를 호출해야 돌아간다.

### while문으로 살펴보는 Iterator
- 반복자체를 하지는 않지만
- 외부에서 반복을 하려고 할 때
- 반복에 필요한 조건과 실행을
- 미리 준비해 둔 객체

\>

- 반복 행위와 반복을 위한 준비를 분리

\>

- 미리 반복에 대한 준비를 해두고
- 필요할 때 필요한 만큼 반복
- 반복을 재현할 수 있음

- Iterator Interface

```javascript
{
    arr: [1,2,3,4],
    next() {
        return {
            done: this.arr.length == 0,
            value: console.log(this.arr.pop())
        };
    }
}
```

## ES6+ LOOP
- 지연실행에 기반한 iterator 객체를 소비하는 형태
- 객체의 상태에 따른 지연 Loop
- 값을 통한 Loop
- 캡슐화를 통한 Loop
- 언어에선 실행만 해줄게
