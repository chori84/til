# Block, NonBlock & Sync, Async

## Block, NonBlock

### Flow is Blocking
- 프로그램이 실행되면 도중에 멈춰지지 않고 끝까지 실행됨
- Flow는 기본적으로 Block
- 모든 흐름 제어가 끝나야지만 제어권을 반환한다.
- 그동안 CPU는 우리의 통제권을 벗어나 있다.

```javascript
for(const i of (function*() {
    let i = 0;
    while(true) yield i++;
})()) console.log(i);

// script timeout
```

- 플랫폼의 안정성을 위해 블록되는 시간이 길면 강제 종료시킴
- 스크립트를 실행하기 위해 주어진 시간은 약 15초이다.

### Blocking Function
- 점유하는 시간만큼 블록을 일으키는 함수

```javascript
const f = v=>{
    let i = 0;
    while(i++ < v);
    return i;
};
f(10);
f(1000000000000);
```

- 함수가 실행이 완료 될 때까지 제어권이 회복되지 않음.
- 블록 함수를 짤 떄 주의할 점은 어딘가에 limit를 걸어야 한다.
- 그렇지 않으면 os에게 당한다.
- 배열 순회, 정렬 - 배열 크기에 따라
- DOM 순회 - DOM의 하위구조에 따라
- 이미지 프로세싱 - 이미지 크기에 따라

### Blocking Evasion
- 블록킹을 피해야한다.
- 독점적인 cpu 점유로 인해 모든 동작이 정지됨
- 타임아웃체크에 의해 프로그램이 강제 중단됨
- 블록킹의 조합을 예측할 수 없음.

```javascript
const f = v => other(some(v), v * 2);
f(10)
```

- 이 함수가 죽을지 안죽을지 알수가 없다.
- some도 블로킹을 걸고 other도 블로킹을 거는데 어느 함수에서 죽을지 모른다.
- 블록은 예상하기 힘들기 때문에 함수가 블록을 안하는게 최선이다.

- 순차적인 실행
    - 노이만 머신에 따라서 적재 -> 실행 완료 -> 적재 -> 실행 완료 -> ...를 반복한다.
    - 1, 2, 3 순차적으로 실행

- 시분할 운영체제의 동시 실행
    - 1, 2, 1, 2, 3, 1, 2, 1, ...
    - 순차 실행 보다 실행 속도가 느리다.
    - 실행이 바뀔 때 마다 상태를 저장하고 로드하는 시간이 걸리기 때문에 (컨텍스트 스위칭 비용)
    - 요즘엔 한 코어에 한 실행을 할당한다.
    - 블록킹을 피하려면 일을 각각 다른 cpu에 맡긴다.
    - flow가 즉시 제어권을 회복하는 것을 nonBlocking이라고 한다.

- 자바스크립트 쓰레드
    - Main UI Thread I
    - Background Thread N
    - Web Worker Thread
    